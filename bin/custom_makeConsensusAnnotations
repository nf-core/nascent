#' custom_makeConsensusAnnotations Makes a consensus annotation #'
#' Makes a non-overlapping consensus annotation.  Gene annotations are often
#' overalpping due to #' multiple isoforms for a gene.
#' In consensus annotation, isoforms are first reduced so that only
#' redundant intervals are used to represent a genomic interval for a gene,
#' i.e., a gene id.
#' Remaining unresolved annotations are further reduced by truncating 3'
#' end of annotations.
#'
#' Supports parallel processing using mclapply in the 'parallel' package.
#' To change the number of processors, use the argument 'mc.cores'.
#'
#' @param ar GRanges of annotations to be collapsed.
#' @param minGap Minimun gap between overlapped annotations after truncated.
#' Default: 1L
#' @param minWidth Minimun width of consensus annotations. Default: 1000L
#' @param ... Extra argument passed to mclapply.
#' @return Returns GRanges object of annotations.
#' @author Minho Chae
#' @examples
#' ## Not run:
#' # library(TxDb.Hsapiens.UCSC.hg19.knownGene)
#' # txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
#' # tx <- transcripts(txdb, columns=c("gene_id", "tx_id", "tx_name"),
#'                           filter=list(tx_chrom="chr7"))
#' # tx <- tx[grep("random", as.character(seqnames(tx)), invert=TRUE),]
#' # ca <- makeConsensusAnnotations(tx)
custom_makeConsensusAnnotations <- function(ar, minGap=1L, minWidth=1000L, ...) {
    # check missing gene_id
    missing <- elementNROWS(mcols(ar)[,"gene_id"]) == 0
    if (any(missing)) {
        ar <- ar[!missing,]
        warning(sum(missing), " ranges do not have gene_id and they are
            dropped")
    }

    many <- elementNROWS(mcols(ar)[, "gene_id"]) > 1
    if (any(many)) {
        ar <- ar[!many, ]
        warning(sum(many), " ranges have multiple gene_id and they are
            dropped")
    }

    ar_list <- split(ar, unlist(mcols(ar)[, "gene_id"]))
    singles <- unlist(ar_list[elementNROWS(ar_list) == 1])
    isoforms <- ar_list[elementNROWS(ar_list) > 1]

    message("Reduce isoforms(", length(isoforms),") ... ", appendLF=FALSE)
    isoforms <- GRangesList(mclapply(isoforms, function(x) {
        # For mixed strands or chrom, choose the longest
        if ((length(seqlevelsInUse(x)) > 1) ||
                (length(unique(strand(x))) > 1)) {
            result <- x[which.max(width(x)), "gene_id"]
        } else {
            dx <- disjoin(x)
            mcols(dx)$gene_id <- mcols(x)$gene_id[1]
            olcnt <- countOverlaps(dx, x)

            multi <- dx[olcnt > 1]    # Use the disjoint ranges
                                      # covered more than once
            if (length(multi) == 0) { # For non-overlapping isoforms,
                                      # choose the longest
                result <- x[which.max(width(x)), "gene_id"]
            } else if (length(multi) == 1) {
                result <- multi
            } else {
                reduced <- reduce(multi)
                if (length(reduced) == 1)
                    result <- reduced
                else (length(reduced) > 1)
                    result <- reduced[which.max(width(reduced)),]

            }
            mcols(result)$gene_id <- mcols(x)$gene_id[1]
        }
        return(result)
    }, ...))
    isoforms <- unlist(isoforms)
    message("OK")

    # Check redundancy
    isoforms <- removeRedundant(isoforms)
    singles <- removeRedundant(singles)

    o <- findOverlaps(singles, isoforms, type = "equal")
    if (length(o) != 0) {
        singles <- singles[-queryHits(o), ]
    }

    o <- findOverlaps(singles, isoforms, type = "within")
    if (length(o) != 0) {
        singles <- singles[-queryHits(o), ]
    }

    o <- findOverlaps(isoforms, singles, type = "within")
    if (length(o) != 0) {
        isoforms <- isoforms[-queryHits(o), ]
    }

    noiso <- sort(c(isoforms, singles[, "gene_id"]))
    message("Truncate overlapped ranges ... ", appendLF=FALSE)
    # with different gene_ids
    while(!isDisjoint(noiso)) {
        ol <- findOverlaps(noiso, drop.self=TRUE, drop.redundant=TRUE)
        ol_gr <- GRangesList(lapply(1:length(ol), function(x) {
            sort(c(
                noiso[queryHits(ol)[x]],
                noiso[subjectHits(ol)[x]]
            ))
        }))

        # Truncate 3' end
        ol_gr <- unlist(endoapply(ol_gr, function(x) {
            if (as.character(strand(x[1, ])) == "+") {
                end(x[1, ]) <- start(x[2, ]) - minGap
                # first range's end is truncated
            } else {
                start(x[2, ]) <- end(x[1, ]) + minGap
                # sencond range's end is truncated
            }
            x
        }))

        # Remove any ranges with duplicated names since they already adujsted
        # in the previous call
        ol_gr <- ol_gr[!duplicated(names(ol_gr)), ]

        noiso <- noiso[-unique(c(queryHits(ol), subjectHits(ol))), ]
        # update noiso
        noiso <- c(noiso, ol_gr)
    }
    message("OK")

    noiso <- noiso[width(noiso) >= minWidth, ]
    return(sort(noiso))
}

removeRedundant <- function(annox) {
    o <- findOverlaps(annox, drop.self=TRUE, type="equal",
            drop.redundant=TRUE)
    if(length(o) != 0)
        annox <- annox[-subjectHits(o),]

    o <- findOverlaps(annox, drop.self=TRUE, type="within",
            drop.redundant=TRUE)
    if(length(o) != 0)
        annox <- annox[-queryHits(o),]

    return(annox)
}




## TESTING
suppressPackageStartupMessages(library(groHMM))
suppressPackageStartupMessages(library(testthat))
suppressPackageStartupMessages(library(GenomicRanges))
suppressPackageStartupMessages(library(rtracklayer))

test_that("custom_makeConsensusAnnotations maintains accuracy", {
    # Load the GTF file
    gtf_url <- "https://gist.github.com/edmundmiller/c142801995689ed8d15ebcf40b2fb042/raw/eca3b955312209b5845cca084bb506d5250b3d33/hg19.chr7.refGene.gtf"
    gtf <- import(gtf_url)

    # Extract transcripts from the GTF
    transcripts <- gtf[gtf$type == "transcript"]

    # Create a sample GRanges object
    set.seed(42)
    n <- 100
    sample_ranges <- transcripts
    print("Sample ranges:")
    print(sample_ranges)

    # Run both original and refactored functions
    original_result <- groHMM::makeConsensusAnnotations(sample_ranges)
    refactored_result <- custom_makeConsensusAnnotations(sample_ranges)

    print("Refactored result:")
    print(refactored_result)

    # Compare results
    expect_equal(length(original_result), length(refactored_result))
    expect_equal(sum(width(original_result)), sum(width(refactored_result)))

    if (length(original_result) > 0 && length(refactored_result) > 0) {
        expect_equal(
            sort(unique(mcols(original_result)$gene_id)),
            sort(unique(mcols(refactored_result)$gene_id))
        )
    } else {
        print("Warning: One or both results are empty.")
    }

    # Additional detailed comparisons
    print(paste("Original result length:", length(original_result)))
    print(paste("Refactored result length:", length(refactored_result)))
    print(paste("Original result total width:", sum(width(original_result))))
    print(paste("Refactored result total width:", sum(width(refactored_result))))
    print(paste("Original result unique gene_ids:", length(unique(mcols(original_result)$gene_id))))
    print(paste("Refactored result unique gene_ids:", length(unique(mcols(refactored_result)$gene_id))))

    # Compare the first few entries
    print("First 5 entries of original result:")
    print(head(original_result, 5))
    print("First 5 entries of refactored result:")
    print(head(refactored_result, 5))
})
