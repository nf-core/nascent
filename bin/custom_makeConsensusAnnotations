#' custom_makeConsensusAnnotations Makes a consensus annotation #'
#' Makes a non-overlapping consensus annotation.  Gene annotations are often
#' overalpping due to #' multiple isoforms for a gene.
#' In consensus annotation, isoforms are first reduced so that only
#' redundant intervals are used to represent a genomic interval for a gene,
#' i.e., a gene id.
#' Remaining unresolved annotations are further reduced by truncating 3'
#' end of annotations.
#'
#' Supports parallel processing using mclapply in the 'parallel' package.
#' To change the number of processors, use the argument 'mc.cores'.
#'
#' @param ar GRanges of annotations to be collapsed.
#' @param minGap Minimun gap between overlapped annotations after truncated.
#' Default: 1L
#' @param minWidth Minimun width of consensus annotations. Default: 1000L
#' @param ... Extra argument passed to mclapply.
#' @return Returns GRanges object of annotations.
#' @author Minho Chae
#' @examples
#' ## Not run:
#' # library(TxDb.Hsapiens.UCSC.hg19.knownGene)
#' # txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
#' # tx <- transcripts(txdb, columns=c("gene_id", "tx_id", "tx_name"),
#'                           filter=list(tx_chrom="chr7"))
#' # tx <- tx[grep("random", as.character(seqnames(tx)), invert=TRUE),]
#' # ca <- makeConsensusAnnotations(tx)
custom_makeConsensusAnnotations <- function(ar, minGap=1L, minWidth=1000L, ...) {
    # Check and remove ranges with missing or multiple gene_ids
    valid_ranges <- vapply(mcols(ar)$gene_id, function(x) length(x) == 1, logical(1))
    if (any(!valid_ranges)) {
        warning(sum(!valid_ranges), " ranges have missing or multiple gene_id and they are dropped")
        ar <- ar[valid_ranges]
    }

    # Split into single-isoform and multi-isoform genes
    gene_counts <- table(mcols(ar)$gene_id)
    singles <- ar[mcols(ar)$gene_id %in% names(gene_counts[gene_counts == 1])]
    multi_isoform_genes <- names(gene_counts[gene_counts > 1])

    # Process multi-isoform genes in chunks
    chunk_size <- 1000  # Adjust based on available memory
    num_chunks <- ceiling(length(multi_isoform_genes) / chunk_size)

    isoforms <- GRangesList()
    for (i in 1:num_chunks) {
        chunk_start <- (i - 1) * chunk_size + 1
        chunk_end <- min(i * chunk_size, length(multi_isoform_genes))
        chunk_genes <- multi_isoform_genes[chunk_start:chunk_end]

        chunk_isoforms <- ar[mcols(ar)$gene_id %in% chunk_genes]
        chunk_list <- split(chunk_isoforms, mcols(chunk_isoforms)$gene_id)

        message("Reduce isoforms (chunk ", i, "/", num_chunks, ") ... ", appendLF=FALSE)
        chunk_result <- GRangesList(mclapply(chunk_list, function(x) {
            # For mixed strands or chrom, choose the longest
            if ((length(seqlevelsInUse(x)) > 1) ||
                    (length(unique(strand(x))) > 1)) {
                result <- x[which.max(width(x)), "gene_id"]
            } else {
                dx <- disjoin(x)
                mcols(dx)$gene_id <- mcols(x)$gene_id[1]
                olcnt <- countOverlaps(dx, x)

                multi <- dx[olcnt > 1]    # Use the disjoint ranges
                                          # covered more than once
                if (length(multi) == 0) { # For non-overlapping isoforms,
                                          # choose the longest
                    result <- x[which.max(width(x)), "gene_id"]
                } else if (length(multi) == 1) {
                    result <- multi
                } else {
                    reduced <- reduce(multi)
                    if (length(reduced) == 1)
                        result <- reduced
                    else (length(reduced) > 1)
                        result <- reduced[which.max(width(reduced)),]

                }
                mcols(result)$gene_id <- mcols(x)$gene_id[1]
            }
            return(result)
        }, ...))
        isoforms <- c(isoforms, chunk_result)
        message("OK")
    }
    isoforms <- unlist(isoforms)

    # Check redundancy
    isoforms <- removeRedundant(isoforms)
    singles <- removeRedundant(singles)

    o <- findOverlaps(singles, isoforms, type = "equal")
    if (length(o) != 0) {
        singles <- singles[-queryHits(o), ]
    }

    o <- findOverlaps(singles, isoforms, type = "within")
    if (length(o) != 0) {
        singles <- singles[-queryHits(o), ]
    }

    o <- findOverlaps(isoforms, singles, type = "within")
    if (length(o) != 0) {
        isoforms <- isoforms[-queryHits(o), ]
    }

    noiso <- sort(c(isoforms, singles[, "gene_id"]))
    message("Truncate overlapped ranges ... ", appendLF=FALSE)
    # with different gene_ids
    while(!isDisjoint(noiso)) {
        ol <- findOverlaps(noiso, drop.self=TRUE, drop.redundant=TRUE)
        ol_gr <- GRangesList(lapply(1:length(ol), function(x) {
            sort(c(
                noiso[queryHits(ol)[x]],
                noiso[subjectHits(ol)[x]]
            ))
        }))

        # Truncate 3' end
        ol_gr <- unlist(endoapply(ol_gr, function(x) {
            if (as.character(strand(x[1, ])) == "+") {
                end(x[1, ]) <- start(x[2, ]) - minGap
                # first range's end is truncated
            } else {
                start(x[2, ]) <- end(x[1, ]) + minGap
                # sencond range's end is truncated
            }
            x
        }))

        # Remove any ranges with duplicated names since they already adujsted
        # in the previous call
        ol_gr <- ol_gr[!duplicated(names(ol_gr)), ]

        noiso <- noiso[-unique(c(queryHits(ol), subjectHits(ol))), ]
        # update noiso
        noiso <- c(noiso, ol_gr)
    }
    message("OK")

    noiso <- noiso[width(noiso) >= minWidth, ]
    return(sort(noiso))
}

removeRedundant <- function(annox) {
    o <- findOverlaps(annox, drop.self=TRUE, type="equal",
            drop.redundant=TRUE)
    if(length(o) != 0)
        annox <- annox[-subjectHits(o),]

    o <- findOverlaps(annox, drop.self=TRUE, type="within",
            drop.redundant=TRUE)
    if(length(o) != 0)
        annox <- annox[-queryHits(o),]

    return(annox)
}




## TESTING
suppressPackageStartupMessages(library(groHMM))
suppressPackageStartupMessages(library(testthat))
suppressPackageStartupMessages(library(GenomicRanges))
suppressPackageStartupMessages(library(rtracklayer))

# test_that("custom_makeConsensusAnnotations maintains accuracy", {
#     # Load the GTF file
#     gtf_url <- "https://gist.github.com/edmundmiller/c142801995689ed8d15ebcf40b2fb042/raw/eca3b955312209b5845cca084bb506d5250b3d33/hg19.chr7.refGene.gtf"
#     gtf <- import(gtf_url)

#     # Extract transcripts from the GTF
#     transcripts <- gtf[gtf$type == "transcript"]

#     # Create a sample GRanges object
#     set.seed(42)
#     n <- 100
#     sample_ranges <- transcripts
#     print("Sample ranges:")
#     print(sample_ranges)

#     # Run both original and refactored functions
#     original_result <- groHMM::makeConsensusAnnotations(sample_ranges)
#     refactored_result <- custom_makeConsensusAnnotations(sample_ranges)

#     print("Refactored result:")
#     print(refactored_result)

#     # Compare results
#     expect_equal(length(original_result), length(refactored_result))
#     expect_equal(sum(width(original_result)), sum(width(refactored_result)))

#     if (length(original_result) > 0 && length(refactored_result) > 0) {
#         expect_equal(
#             sort(unique(mcols(original_result)$gene_id)),
#             sort(unique(mcols(refactored_result)$gene_id))
#         )
#     } else {
#         print("Warning: One or both results are empty.")
#     }

#     # Additional detailed comparisons
#     print(paste("Original result length:", length(original_result)))
#     print(paste("Refactored result length:", length(refactored_result)))
#     print(paste("Original result total width:", sum(width(original_result))))
#     print(paste("Refactored result total width:", sum(width(refactored_result))))
#     print(paste("Original result unique gene_ids:", length(unique(mcols(original_result)$gene_id))))
#     print(paste("Refactored result unique gene_ids:", length(unique(mcols(refactored_result)$gene_id))))

#     # Compare the first few entries
#     print("First 5 entries of original result:")
#     print(head(original_result, 5))
#     print("First 5 entries of refactored result:")
#     print(head(refactored_result, 5))
# })

test_that("chm13 custom_makeConsensusAnnotations maintains accuracy", {
    # Load the GTF file
    gff_url <- "./chm13v2.0_RefSeq_Liftoff_v5.1.gff3.gz"
    gff <- import(gff_url)

    print("GFF:")
    print(gff)
    # Extract transcripts from the GTF
    transcripts <- gff[gff$type == "transcript"]
    print("Transcripts:")
    print(transcripts)

    # Create a sample GRanges object
    set.seed(42)
    n <- 100
    sample_ranges <- transcripts
    print("Sample ranges:")
    print(sample_ranges)

    # Run both original and refactored functions
    original_result <- groHMM::makeConsensusAnnotations(sample_ranges)
    refactored_result <- custom_makeConsensusAnnotations(sample_ranges)

    print("Refactored result:")
    print(refactored_result)

    # Compare results
    expect_equal(length(original_result), length(refactored_result))
    expect_equal(sum(width(original_result)), sum(width(refactored_result)))

    if (length(original_result) > 0 && length(refactored_result) > 0) {
        expect_equal(
            sort(unique(mcols(original_result)$gene_id)),
            sort(unique(mcols(refactored_result)$gene_id))
        )
    } else {
        print("Warning: One or both results are empty.")
    }

    # Additional detailed comparisons
    print(paste("Original result length:", length(original_result)))
    print(paste("Refactored result length:", length(refactored_result)))
    print(paste("Original result total width:", sum(width(original_result))))
    print(paste("Refactored result total width:", sum(width(refactored_result))))
    print(paste("Original result unique gene_ids:", length(unique(mcols(original_result)$gene_id))))
    print(paste("Refactored result unique gene_ids:", length(unique(mcols(refactored_result)$gene_id))))

    # Compare the first few entries
    print("First 5 entries of original result:")
    print(head(original_result, 5))
    print("First 5 entries of refactored result:")
    print(head(refactored_result, 5))
})
